package com.aspire.mirror.ops.biz.vulnerability;

import com.aspire.mirror.ops.api.domain.*;
import com.aspire.mirror.ops.api.domain.vulnerability.*;

import com.aspire.mirror.ops.biz.AgentHostDataBiz;
import com.aspire.mirror.ops.biz.OpsActionBiz;
import com.aspire.mirror.ops.biz.OpsVulnerabilityGroupBiz;
import com.aspire.mirror.ops.biz.model.OpsVulnerabilityScanCycle;
import com.aspire.mirror.ops.controller.authcontext.RequestAuthContext;
import com.aspire.mirror.ops.dao.OpsVulnerabilityDao;

import com.aspire.mirror.ops.domain.AgentHostInfo;
import com.aspire.mirror.ops.exception.OpsServiceException;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
//import javafx.util.Pair;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

import org.apache.commons.lang3.tuple.Pair;

import static com.aspire.mirror.ops.api.domain.OpsPipelineInstanceDTO.*;

/**
 * 项目名称: ops-service
 * <p/>
 * <p>
 * 类名: VulnerabilityBiz
 * <p/>
 * <p>
 * 类功能描述: TODO
 * <p/>
 *
 * @author pengguihua
 * @version V1.0 <br/>
 *
 * <b>Copyright(c)</b> 2020 卓望公司-版权所有
 * @date 2020年7月8日
 */
@Service
@Transactional
@Slf4j
public class VulnerabilityBiz {
    @Autowired
    private OpsVulnerabilityGroupBiz vulGroupBiz;
    @Autowired
    private OpsVulnerabilityDao vulDao;
    
    @Autowired
    private OpsActionBiz opsActionBiz;
    @Autowired
    private AgentHostDataBiz agentHostBiz;

    @Transactional(readOnly = true)
    public PageListQueryResult<OpsVulnerability> queryVulnerabilityList(OpsVulnerabilityQueryModel queryParam) {
        if (StringUtils.isEmpty(queryParam.getOrderColumn())) {
            queryParam.setOrderColumn("update_time");
        }
        if (StringUtils.isEmpty(queryParam.getOrderType())) {
            queryParam.setOrderType("desc");
        }
        List<OpsVulnerability> vulnerabilityList = vulDao.getVulnerabilityList(queryParam);
        if (!CollectionUtils.isEmpty(vulnerabilityList)) {
            vulnerabilityList.stream().forEach(item -> {
                if (item.getRiskLevel() != null) {

                    item.setRiskLevelDesc(RiskLevelEnum.fromStatusCode(item.getRiskLevel()).getLabel());
                }
            });
        }
        if (CollectionUtils.isEmpty(vulnerabilityList)) {
            return new PageListQueryResult<>(0, vulnerabilityList);
        }
        Integer totalSize = vulDao.getVulnerabilityListTotalSize(queryParam);
        return new PageListQueryResult<>(totalSize, vulnerabilityList);
    }

    @Transactional(readOnly = true)
    public OpsVulnerability getVulnerabilityById(String vulId) {
        return vulDao.getVulnerabilityById(vulId);
    }
    

    public List<Object> getRiskLevelList() {
        List<Object> list = Lists.newArrayList();
        for (RiskLevelEnum riskLevelEnum : RiskLevelEnum.values()) {
            Pair<String, String> obj = Pair.of(riskLevelEnum.getStatusCode(), riskLevelEnum.getLabel());
            list.add(obj);
        }
        return list;
    }

    /**
     * 功能描述: 标记 所有非当前扫描周期的漏洞实例记录为历史数据-----在每月漏洞报告数据入库时使用
     * <p>
     */
    public void markPreviousVulInstanceDataList2History(String currScanCycle) {
        vulDao.markPreviousVulInstanceDataList2History(currScanCycle);
    }

    public GeneralResponse updateOpsVulnerability(OpsVulnerability vul) {
        // 分组ID修改
        if (null != vul.getGroupId()) {
            List<VulnerabilityGroupRelation> vulnerabilityGroupRelationList = new ArrayList<>();
            VulnerabilityGroupRelation vulnerabilityGroupRelation = new VulnerabilityGroupRelation(vul.getGroupId(), vul.getId());
            vulnerabilityGroupRelationList.add(vulnerabilityGroupRelation);
            vulGroupBiz.updateVulnerabilityGroupRelation(vulnerabilityGroupRelationList);
        }
        vulDao.updateOpsVulnerability(vul);
        return new GeneralResponse(true, null, vul);
    }

    @Transactional(readOnly = true)
    public PageListQueryResult<OpsVulnerabilityInstance> queryVulnerabilityInstanceList(OpsVulnerabilityInstanceQueryModel queryParam) {
        if (RequestAuthContext.currentRequestAuthContext().getUser() != null) {
            Map<String, List<String>> resFilterConfig = RequestAuthContext.currentRequestAuthContext().getUser().getResFilterConfig();
            queryParam.setResFilterMap(resFilterConfig);
        }
        List<OpsVulnerabilityInstance> vulnerabilityInstanceList = vulDao.getVulnerabilityInstanceList(queryParam);
//        vulnerabilityInstanceList.stream().forEach(item -> item.setRiskLevelDesc(RiskLevelEnum.fromStatusCode(item.getRiskLevel()).getLabel()));
        if (!CollectionUtils.isEmpty(vulnerabilityInstanceList)) {
            vulnerabilityInstanceList.stream().forEach(item -> {
                if (item.getRiskLevel() != null) {
                    item.setRiskLevelDesc(RiskLevelEnum.fromStatusCode(item.getRiskLevel()).getLabel());
                }
            });
        }
        if (CollectionUtils.isEmpty(vulnerabilityInstanceList)) {
            return new PageListQueryResult<>(0, Lists.newArrayList());
        }
        Integer totalSize = vulDao.getVulnerabilityInstanceListCount(queryParam);
        return new PageListQueryResult<>(totalSize, vulnerabilityInstanceList);
    }

    public void saveOpsVulnerabilityInstance(OpsVulnerabilityInstance vulInst) {
        OpsVulnerabilityInstance existVulInst = vulDao.getVulnerabilityInstanceByKeys(
                vulInst.getScanCycle(), vulInst.getPoolName(), vulInst.getHostIp(), vulInst.getVulnerabilityId());
        if (existVulInst == null) {
            vulInst.setLastUpdateTime(new Date());
            vulDao.insertOpsVulnerabilityInstance(vulInst);
        } else {
            vulInst.setLastUpdateTime(new Date());
            vulDao.updateOpsVulnerabilityInstance(vulInst);
        }
    }

    public OpsVulnerabilityInstance getVulnerabilityInstanceById(Long id) {
        return vulDao.getVulnerabilityInstanceById(id);
    }

    public GeneralResponse updateOpsVulnerabilityInstance(OpsVulnerabilityInstance vulInstance) {
        vulDao.updateOpsVulnerabilityInstance(vulInstance);
        return new GeneralResponse(true, null, vulInstance);
    }

    @Transactional(readOnly = true)
    public OpsVulnerabilityScanCycle getVulScanCycleByKey(String scanCycle) {
        return vulDao.getVulScanCycleByKey(scanCycle);
    }

    public OpsVulnerabilityRepairExecuteLog getVulRepairExecutelogByExecuteUuid(String executeUuid) {
        return vulDao.getVulRepairExecutelogByExecuteUuid(executeUuid);
    }

    /**
     * 功能描述: 执行漏洞修复作业
     * <p>
     *
     * @param vulInstanceId
     * @param pipelineId
     * @return
     */
    @Transactional
    public GeneralResponse executeVulnerabilityRepair(Long vulInstanceId, Long pipelineId, String operateType) {
        OpsVulnerabilityInstance vulInstance = vulDao.getVulnerabilityInstanceById(vulInstanceId);
        if (vulInstance == null) {
            throw new OpsServiceException("There is no vulnerablity instance with id " + vulInstanceId);
        }

        AgentHostInfo agentHost = agentHostBiz.queryAgentDataByPoolAndAgentIP(vulInstance.getPoolName(), vulInstance.getHostIp());
        if (agentHost == null) {
            String tip = String.format("There is no agent host with pool:%s, agentIp:%s, "
                    + "the Vulnerability process will be ignored.", vulInstance.getPoolName(), vulInstance.getHostIp());
            log.error(tip);
            return new GeneralResponse(false, tip);
        }

        final List<String> targetHostList = new ArrayList<>();
        targetHostList.add(agentHost.getConcatHost());
        final Map<String, Object> replaceAttrs = new HashMap<>();
        replaceAttrs.put("target_hosts", targetHostList);
        OpsMessageExtendMeta extendMeta = null;
        if (operateType.equals(OpsVulnerabilityInstance.OPERATE_REPAIR)) {
            extendMeta = new OpsMessageExtendMeta(BIZ_CLASSIFY_VUL_REPAIR);
        } else if (operateType.equals(OpsVulnerabilityInstance.OPERATE_GO_BACK)){
            extendMeta = new OpsMessageExtendMeta(BIZ_CLASSIFY_VUL_GO_BACK);
        } else {
            extendMeta = new OpsMessageExtendMeta(BIZ_CLASSIFY_VUL_RECHECK);
        }
        extendMeta.addExtendAttr("vulId", vulInstance.getVulId());
        extendMeta.addExtendAttr("vulInstanceId", vulInstanceId);
        extendMeta.addExtendAttr("operator", RequestAuthContext.getRequestHeadUserName());
        GeneralResponse executeResp
                = opsActionBiz.executePipeline(pipelineId, OpsTriggerWayEnum.TRIGGER_BY_API, replaceAttrs, extendMeta);
        if (executeResp.isFlag()) {
            Long pipeInstanceId = Long.valueOf(String.valueOf(executeResp.getBizData()));
            // 记录到执行日志表
            OpsVulnerabilityRepairExecuteLog executeLog = new OpsVulnerabilityRepairExecuteLog();
            executeLog.setVulnerabilityInstanceId(vulInstanceId);
            executeLog.setPipelineInstanceId(pipeInstanceId);
            executeLog.setOperator(RequestAuthContext.getRequestHeadUserName());
            executeLog.setOperateType(operateType);
            executeLog.setExecuteTime(new Date());
            vulDao.insertOpsVulRepairExecuteLog(executeLog);
        }
        return executeResp;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void saveScanCycleInfo(OpsVulnerabilityScanCycle scanCycleInfo) {
        OpsVulnerabilityScanCycle existScanCycle = vulDao.getVulScanCycleByKey(scanCycleInfo.getScanCycle());
        if (existScanCycle == null) {
            if(StringUtils.isBlank(scanCycleInfo.getStatus())) {
                scanCycleInfo.setProcessOk();
            }
            scanCycleInfo.setCreateTime(new Date());
            vulDao.insertOpsVulScanCycle(scanCycleInfo);
        } else {
            vulDao.updateOpsVulScanCycle(scanCycleInfo);
        }
    }

    @Transactional(readOnly = true)
    public List<OpsVulPoolCodeNameMap> loadPoolCodeNameMapList() {
        return vulDao.loadPoolCodeNameMapList();
    }

    public GeneralResponse saveVulnerability(OpsVulnerability vul) {
        String vulId = vul.resolveVulId();
        if (StringUtils.isBlank(vulId)) {
            log.warn("The vul record will be ignored as the id is empty '{}'.", vul);
            return new GeneralResponse(false, "该漏洞ID为空");
        }
        if (!isVulnerabilityExists(vulId)) {
            // 插入分组数据
            if (vul.getGroupId() != null) {
                VulnerabilityGroupRelation vulnerabilityGroupRelation = new VulnerabilityGroupRelation();
                vulnerabilityGroupRelation.setVulnerabilityGroupId(vul.getGroupId());
                vulnerabilityGroupRelation.setVulnerabilityId(vulId);
                vulGroupBiz.addVulnerabilityGroupRelation(vulnerabilityGroupRelation);
            } else {
                vulGroupBiz.addVulnerabilityGroupRelation(vul);
            }
            vulDao.insertOpsVulnerability(vul);
            VulnerabilityScanResultImportJob.existVulCache.put(vul.getId(), vul);
        }
        return new GeneralResponse(true);
    }

    /**
     * 功能描述: 判断漏洞信息是否已经存在
     * <p>
     *
     * @param vulId
     * @return
     */
    private boolean isVulnerabilityExists(String vulId) {
        OpsVulnerability dbVul = vulDao.getVulnerabilityById(vulId);
        if (dbVul != null) {
            return true;
        }
        return false;
    }

    public Map<String, Integer> addBatchVulnerability(List<OpsVulnerability> vulList) {
        List<OpsVulnerability> addVulList = Lists.newArrayList();
        Map<String, Integer> result = Maps.newHashMap();
        Integer updateNum = 0;
        Integer untreatedNum = 0;
        for (OpsVulnerability vul : vulList) {
            String vulId = vul.resolveVulId();
            if (!StringUtils.isEmpty(vulId)) {
                OpsVulnerability existVul = vulDao.getVulnerabilityById(vulId);
                if (existVul != null) {
                    vul.setUpdateTime(new Date());
                    vulDao.updateOpsVulnerability(vul);
                    updateNum++;
                } else {
                    addVulList.add(vul);
                    vulGroupBiz.addVulnerabilityGroupRelation(vul);
                }
            } else {
                List<OpsVulnerability> existVul = vulDao.getVulnerabilityByName(vul.getName());
                if (CollectionUtils.isEmpty(existVul)) {
                    vul.setId(UUID.randomUUID().toString());
                    addVulList.add(vul);
                    vulGroupBiz.addVulnerabilityGroupRelation(vul);
                } else {
                    untreatedNum++;
                }
            }
            // 更新缓存
            if (StringUtils.isNoneBlank(vul.getId())) {
                VulnerabilityScanResultImportJob.existVulCache.put(vul.getId(), vul);
            }
        }
        if (addVulList.size() > 0) {
            vulDao.batchInsertVulnerability(addVulList);
        }
        result.put("insert_num", addVulList.size());
        result.put("update_num", updateNum);
        result.put("untreated_num", untreatedNum);
        return result;
    }

    public List<OpsVulnerabilityReportItem> getVulnerabilityReport(OpsVulnerabilityReportQuery queryParam) {
        List<OpsVulnerabilityReportItem> result = vulDao.getVulnerabilityReport(queryParam);
        return result;
    }

    public String getNewVulScanCycle() {
        return vulDao.getNewVulScanCycle();
    }

    public String getFlushSerialNum() {
        return vulDao.getFlushSerialNum();
    }

    public List<OpsVulScanCycle> getScanCycleList() {
        return vulDao.getScanCycleList();
    }

    public OpsVulnerabilityInstanceDetail getVulnerabilityInstanceDetailById(Long vulInstanceId) {
        OpsVulnerabilityInstance vulnerabilityInstance = vulDao.getVulnerabilityInstanceById(vulInstanceId);
        OpsVulnerabilityInstanceDetail opsVulnerabilityInstanceDetail = new OpsVulnerabilityInstanceDetail();
        BeanUtils.copyProperties(vulnerabilityInstance, opsVulnerabilityInstanceDetail);

//		BeanUtils.copyProperties(opsVulnerabilityInstanceDetail, vulnerabilityInstance);
        Map<String, Object> map = vulDao.getVulNumStatisticsByVulInstanceId(vulnerabilityInstance.getHostIp(), vulnerabilityInstance.getPoolName());
        opsVulnerabilityInstanceDetail.setHighNum(map.get("highNum").toString());
        opsVulnerabilityInstanceDetail.setMidNum(map.get("midNum").toString());
        opsVulnerabilityInstanceDetail.setLowNum(map.get("lowNum").toString());
        opsVulnerabilityInstanceDetail.setInfoNum(map.get("infoNum").toString());
        return opsVulnerabilityInstanceDetail;
    }

    public void updateFlushSerialNum(String lastSerialNum) {
        vulDao.updateFlushSerialNum(lastSerialNum);
    }

    public GeneralResponse batchExecuteVulnerabilityRepair(BatchExecuteVulnerabilityReqModel execVulModel) {
        if (execVulModel == null || execVulModel.getVulId() == null) {
            return new GeneralResponse(false, "参数异常");
        }
        OpsVulnerability opsVulnerability = vulDao.getVulnerabilityById(execVulModel.getVulId());
        if (opsVulnerability == null) {
            return new GeneralResponse(false, "该漏洞信息不存在");
        }
        List<VulInstanceAgentInfo> isAgentVulInstIdList = vulDao.getWaitRepairVulnerabilityInstanceIdList(execVulModel.getVulId());
        if (CollectionUtils.isEmpty(isAgentVulInstIdList)) {
            return new GeneralResponse(false, "该漏洞没有可执行修复的agent设备");
        }
        ExecutorService executor = Executors.newFixedThreadPool(1);
        CompletableFuture.runAsync(() -> {
            try {
                Map<Long, List<VulInstanceAgentInfo>> vulInstanceIdMap = Maps.newHashMap();
                Long defaultPipelineId = null;
                List<VulInstanceAgentInfo> defaultVulInstIdList = Lists.newLinkedList();
//                List<VulInstanceAgentInfo> isAgentVulInstIdList = Lists.newArrayList();
                if (StringUtils.isNotBlank(execVulModel.getVulId())) {
                    if (StringUtils.isBlank(execVulModel.getDefaultPipelineId())) {
//                    OpsVulnerability opsVulnerability = vulDao.getVulnerabilityById(execVulModel.getVulId());
                        defaultPipelineId = opsVulnerability.getPipelineIdList().get(0);
                    } else {
                        defaultPipelineId = Long.parseLong(execVulModel.getDefaultPipelineId());
                    }
//			defaultVulInstIdList.addAll(isAgentVulInstIdList);
//			vulInstanceIdMap.put(defaultPipelineId, defaultVulInstIdList);
                }
                vulInstanceIdMap.put(defaultPipelineId, defaultVulInstIdList);
                Map<String, VulInstanceAgentInfo> isAgentVulInstIdMap = Maps.newHashMap();
                for (VulInstanceAgentInfo instAgentInfo : isAgentVulInstIdList) {
                    isAgentVulInstIdMap.put(instAgentInfo.getVulInstanceId(), instAgentInfo);
                    if (CollectionUtils.isEmpty(execVulModel.getSpecialVulInstanceList())) {
                        defaultVulInstIdList.add(instAgentInfo);
                    } else {
                        Set<String> instIdSet = execVulModel.getSpecialVulInstanceList().stream().map(item -> item.getVulInstanceId()).collect(Collectors.toSet());
                        if (!instIdSet.contains(instAgentInfo.getVulInstanceId())) {
                            defaultVulInstIdList.add(instAgentInfo);
                        }
                    }
                }
                if (!CollectionUtils.isEmpty(execVulModel.getSpecialVulInstanceList())) {
                    for (VulInstancePipelineModel vulInstancePipelineModel : execVulModel.getSpecialVulInstanceList()) {
                        if (isAgentVulInstIdMap.keySet().contains(vulInstancePipelineModel.getVulInstanceId())) {
                            if (vulInstanceIdMap.get(Long.parseLong(vulInstancePipelineModel.getPipelineId())) == null) {
                                List<VulInstanceAgentInfo> instanceIdList = Lists.newArrayList();
                                instanceIdList.add(isAgentVulInstIdMap.get(vulInstancePipelineModel.getVulInstanceId()));
                                vulInstanceIdMap.put(Long.parseLong(vulInstancePipelineModel.getPipelineId()), instanceIdList);
                            } else {
                                vulInstanceIdMap.get(Long.parseLong(vulInstancePipelineModel.getPipelineId())).add(isAgentVulInstIdMap.get(vulInstancePipelineModel.getVulInstanceId()));
                            }
//					defaultVulInstIdList.remove(vulInstancePipelineModel.getVulInstanceId());
                        }
                    }
                }

                for (Long pipelineId : vulInstanceIdMap.keySet()) {
//			if (agentHost == null) {
//				String tip = String.format("There is no agent host with pool:%s, agentIp:%s, "
//						+ "the VulnerabilityRepair process will be ignored.", vulInstance.getPoolName(), vulInstance.getHostIp());
//				log.error(tip);
//				return new GeneralResponse(false, tip);
//			}

                    final List<String> targetHostList = vulInstanceIdMap.get(pipelineId).stream().map(item -> item.getAgentIp()).collect(Collectors.toList());
//			targetHostList.add(agentHost.getConcatHost());
                    final Map<String, Object> replaceAttrs = new HashMap<>();
                    replaceAttrs.put("target_hosts", targetHostList);

                    OpsMessageExtendMeta extendMeta = new OpsMessageExtendMeta(BIZ_CLASSIFY_VUL_REPAIR);
                    List<String> vulInstList = vulInstanceIdMap.get(pipelineId).stream().map(item -> item.getVulInstanceId()).collect(Collectors.toList());
                    extendMeta.addExtendAttr("vulInstanceId", Joiner.on(",").join(vulInstList));
                    extendMeta.addExtendAttr("operator", RequestAuthContext.getRequestHeadUserName());
                    GeneralResponse executeResp
                            = opsActionBiz.executePipeline(pipelineId, OpsTriggerWayEnum.TRIGGER_BY_API, replaceAttrs, extendMeta);
                    Long pipeInstanceId = Long.parseLong(String.valueOf(executeResp.getBizData()));
                    if (executeResp.isFlag()) {
                        // 记录到执行日志表
                        for (VulInstanceAgentInfo vulInstAgent : vulInstanceIdMap.get(pipelineId)) {
                            OpsVulnerabilityRepairExecuteLog executeLog = new OpsVulnerabilityRepairExecuteLog();
                            executeLog.setVulnerabilityInstanceId(Long.parseLong(vulInstAgent.getVulInstanceId()));
                            executeLog.setPipelineInstanceId(pipeInstanceId);
                            executeLog.setOperator(RequestAuthContext.getRequestHeadUserName());
                            executeLog.setExecuteTime(new Date());
                            vulDao.insertOpsVulRepairExecuteLog(executeLog);
                        }
                    } else {
                        log.error("vul pipeline exec is error! pipelineId" + pipelineId + ", error info :" + executeResp.getErrorTip());
                    }
                }
            } catch (Exception e) {
                log.error("exec vul pipeline is error!", e);
            }
        }, executor);
        return new GeneralResponse();
    }

    public void flushOpsVulnerabilityIsFixed(String vulnerabilityId, String scanCycle) {
        vulDao.flushOpsVulnerabilityIsFixed(vulnerabilityId, scanCycle);
    }

    public OpsVulnerability getVulnerabilityByName(String name) {
        List<OpsVulnerability> listVul = vulDao.getVulnerabilityByName(name);
        if (!CollectionUtils.isEmpty(listVul)) {
            return listVul.get(0);
        }
        return null;
    }

    public PageListQueryResult<OpsVulnerabilityNewReportItem> getVulNewReport(OpsVulNewReportQuery queryParam) {
        Integer count = vulDao.getVulNewReportTotalSize(queryParam);
        List<OpsVulnerabilityNewReportItem> result;
        if (count > 0) {
            result = vulDao.getVulNewReport(queryParam);
        } else {
            result = Lists.newArrayList();
        }
        return new PageListQueryResult<>(count, result);
    }

    public List<VulReportDetailStatistics> queryVulReportDetailStatistics(OpsVulNewReportQuery queryParam) {
        return vulDao.queryVulReportDetailStatistics(queryParam);
    }

    public PageListQueryResult<VulReportDetailItem> queryVulReportItemList(OpsVulNewReportQuery queryParam) {
        Integer totalCount = vulDao.queryVulReportItemListTotalSize(queryParam);
        List<VulReportDetailItem> itemList;
        if (totalCount > 0) {
            itemList = vulDao.queryVulReportItemList(queryParam);
        } else {
            itemList = Lists.newArrayList();
        }
        return new PageListQueryResult<>(totalCount, itemList);
    }
}
