package com.aspire.mirror.ops.biz.vulnerability;

import java.io.IOException;
import java.util.*;
import java.util.stream.Collectors;

import com.alibaba.fastjson.JSON;
import com.aspire.mirror.common.util.DateUtil;
import com.aspire.mirror.ops.api.domain.PageListQueryResult;
import com.aspire.mirror.ops.api.domain.RiskLevelEnum;
import com.aspire.mirror.ops.api.domain.vulnerability.OpsVulnerabilityInstanceQueryModel;
import com.aspire.mirror.ops.api.domain.vulnerability.OpsVulnerabilityQueryModel;
import com.aspire.mirror.ops.clientservice.CmdbServiceClient;
import com.aspire.mirror.ops.clientservice.model.CmdbListResponse;
import com.google.common.collect.Lists;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;
import org.elasticsearch.action.search.*;
import org.elasticsearch.client.RequestOptions;
import org.elasticsearch.client.RestHighLevelClient;
import org.elasticsearch.common.unit.TimeValue;
import org.elasticsearch.index.query.BoolQueryBuilder;
import org.elasticsearch.index.query.MatchAllQueryBuilder;
import org.elasticsearch.index.query.QueryBuilders;
import org.elasticsearch.index.query.RangeQueryBuilder;
import org.elasticsearch.search.Scroll;
import org.elasticsearch.search.SearchHit;
import org.elasticsearch.search.builder.SearchSourceBuilder;
import org.elasticsearch.search.sort.SortOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Isolation;
import org.springframework.transaction.annotation.Transactional;

import com.aspire.mirror.ops.api.domain.vulnerability.OpsVulnerability;
import com.aspire.mirror.ops.api.domain.vulnerability.OpsVulnerabilityInstance;
import com.aspire.mirror.ops.api.domain.vulnerability.OpsVulnerabilityInstance.VulnerabilityStatus;
import com.aspire.mirror.ops.biz.model.OpsVulnerabilityScanCycle;
import com.aspire.mirror.ops.exception.OpsServiceException;
import com.aspire.mirror.ops.util.JsonUtil;
import com.google.common.base.Joiner;
import com.google.common.collect.Maps;
import com.jayway.jsonpath.DocumentContext;

import lombok.extern.slf4j.Slf4j;

import javax.annotation.PostConstruct;

/**
 * 项目名称: ops-service
 * <p/>
 * <p>
 * 类名: VulnerabilityScanResultImportJob
 * <p/>
 * <p>
 * 类功能描述: 漏洞扫描结果导入定时任务
 * <p/>
 *
 * @author pengguihua
 * @date 2020年7月7日
 * @version V1.0 <br/>
 *
 * <b>Copyright(c)</b> 2020 卓望公司-版权所有
 */
@Slf4j
@Service
public class VulnerabilityScanResultImportJob {
    protected volatile String flushSerialNum = new String();
    @Autowired
    private RestHighLevelClient restHighClient;

    @Value("${vulnerability.index_name}")
    private String indexName;

    @Value("${vulnerability.batch_size:800}")
    private Integer batchSize;

    @Value("${agent.loadfrom:local}")
    private String agentLoadType;                    // cmdb: cmdb服务加载        local: 本地服务加载

    @Autowired
    private CmdbServiceClient cmdbClient;

    @Autowired
    private VulnerabilityBiz vulBiz;

    private static final String LOAD_FROM_CDMB = "cmdb";

    public static final Map<String, OpsVulnerability> existVulCache = Maps.newHashMap();

    private final Map<String, String> poolCodeMapName = new HashMap<>();

    @Value("${vulnerability.manual_index_name:manual_security_index_*}")
    private String manualIndexName;

    private static final String SERIAL_FIELD = "time_unique";

    /**
     * 功能描述: 每月的26,27,28的凌晨1点执行
     * <p>
     */
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    @Scheduled(cron = "0 0 1 26,27,28 * ? ")
    public void runJob() {
        String scanCycle = getScanCycle();
        OpsVulnerabilityScanCycle scanCycleRecord = vulBiz.getVulScanCycleByKey(scanCycle);
        if (scanCycleRecord != null && scanCycleRecord.isProcessOk()) {
            log.info("The vulnerability scan cycle {} had been processed.", scanCycle);
            return;
        }

        log.info("Begin to resolve vulnerability scan result for {}.", scanCycle);
        try {
//			prepare();
            readFromEs(scanCycle);
        } catch (Exception e) {
            vulBiz.saveScanCycleInfo(OpsVulnerabilityScanCycle.from(scanCycle, false));
            String tip = String.format("Error resolve vulnerability scan result for %s.", scanCycle);
            throw new OpsServiceException(tip, e);
        }
    }

    /**
     * 功能描述: 每分钟30秒扫描es
     * <p>
     */
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    @Scheduled(cron = "30 */1 * * * ?")
    public void runRealTimeJob() {
        if (StringUtils.isEmpty(flushSerialNum)) {
            flushSerialNum = vulBiz.getFlushSerialNum();
        }
        String lastSerialNum = this.getLastSerialNum();
//		Thread.sleep(1000);
        if (lastSerialNum == null) {
            lastSerialNum = flushSerialNum;
        }
        this.handleImportVul(flushSerialNum, lastSerialNum);
        vulBiz.updateFlushSerialNum(lastSerialNum);
        flushSerialNum = lastSerialNum;
    }

    private void handleImportVul(String flushSerialNum, String lastSerialNum) {
//        String scanCycle = vulBiz.getNewVulScanCycle();

        SearchRequest req = new SearchRequest();
        req.indices(manualIndexName);
        req.scroll(new Scroll(TimeValue.timeValueMinutes(5)));
        // 查询条件
        final BoolQueryBuilder bqb = QueryBuilders.boolQuery();
        RangeQueryBuilder timeRange = QueryBuilders.rangeQuery(SERIAL_FIELD);
        if (StringUtils.isNotBlank(flushSerialNum)) {
            timeRange.gt(flushSerialNum);
        }
        timeRange.lte(lastSerialNum);
//		timeRange.lte(DateUtil.getDate(lastSerialNum, DateUtil.DATE_TIME_MS_FORMAT).getTime());
        bqb.must(timeRange);
        SearchSourceBuilder ssBuilder = SearchSourceBuilder.searchSource();
        ssBuilder.query(bqb).sort(SERIAL_FIELD, SortOrder.DESC);
        ssBuilder.size(batchSize);
        req.source(ssBuilder);

        SearchResponse response = null;
        try {
            response = restHighClient.search(req, RequestOptions.DEFAULT);
            String scrollId = response.getScrollId();
            SearchHit[] hits = response.getHits().getHits();
            handleSearchList(hits, null);

            while (hits.length > 0) {
                SearchScrollRequest scrollReq = new SearchScrollRequest(scrollId);
                response = restHighClient.scroll(scrollReq, RequestOptions.DEFAULT);
                hits = response.getHits().getHits();
                handleSearchList(hits, null);
            }

            ClearScrollRequest clearScrollReq = new ClearScrollRequest();
            clearScrollReq.addScrollId(scrollId);
            restHighClient.clearScroll(clearScrollReq, RequestOptions.DEFAULT);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private String getLastSerialNum() {
        SearchRequest req = new SearchRequest();
        req.indices(manualIndexName);
        SearchSourceBuilder ssBuilder = SearchSourceBuilder.searchSource();
        //TODO XXX为所有唯一递增序列号
        ssBuilder.query(new MatchAllQueryBuilder()).sort(SERIAL_FIELD, SortOrder.DESC);
        ssBuilder.size(1);
        req.source(ssBuilder);
        SearchResponse resp = null;
        try {
            resp = restHighClient.search(req, RequestOptions.DEFAULT);
            if (resp.getHits().getTotalHits() > 0) {
                Map<String, Object> result = resp.getHits().getHits()[0].getSourceAsMap();
                Long serial = (Long) result.get(SERIAL_FIELD);
                return Long.toString(serial);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return null;
    }

    private String getScanCycle() {
        Calendar cal = Calendar.getInstance();
        int month = cal.get(Calendar.MONTH) + 1;
        return cal.get(Calendar.YEAR) + "" + (month < 10 ? "0" + month : month);
    }

    @PostConstruct
    private void prepare() {
        existVulCache.clear();
        poolCodeMapName.clear();
        vulBiz.loadPoolCodeNameMapList().forEach(
                codeName -> poolCodeMapName.put(codeName.getPoolCode(), codeName.getPoolName()));
    }

    /**
     * 功能描述: 判断漏洞信息是否已经存在
     * <p>
     *
     * @param vulId
     * @return
     */
    private boolean isVulnerabilityExists(String vulId) {
        Set<String> ids = existVulCache.keySet();
        boolean flag = ids.contains(vulId);
        if (flag) {
            return true;
        }
        OpsVulnerability dbVul = vulBiz.getVulnerabilityById(vulId);
        if (dbVul != null) {
            cacheOpsVulnerability(dbVul);
            return true;
        }
        return false;
    }

    private void cacheOpsVulnerability(OpsVulnerability dbVul) {
        existVulCache.put(dbVul.getId(), dbVul);
    }

    /**
     * 功能描述: 从ES读取扫描结果
     * <p>
     *
     * @param scanCycle
     * @throws Exception
     */
    private void readFromEs(String scanCycle) throws Exception {
        int processHostCount = 0;
        for (String index : indexName.trim().split(",")) {
            String descoverProducer = "";
            if (index.startsWith("lvmeng")) {
                descoverProducer = "lvmeng";
            } else if (index.startsWith("qiming")) {
                descoverProducer = "qiming";
            }
            SearchRequest req = new SearchRequest();
            req.indices(index);
            req.scroll(new Scroll(TimeValue.timeValueMinutes(5)));
            SearchSourceBuilder ssBuilder = SearchSourceBuilder.searchSource();
            ssBuilder.query(new MatchAllQueryBuilder());
            ssBuilder.size(batchSize);
            req.source(ssBuilder);

            SearchResponse response = restHighClient.search(req, RequestOptions.DEFAULT);
            String scrollId = response.getScrollId();
            SearchHit[] hits = response.getHits().getHits();
            handleSearchList(hits, descoverProducer);
            processHostCount += hits.length;

            while (hits.length > 0) {
                SearchScrollRequest scrollReq = new SearchScrollRequest(scrollId);
                response = restHighClient.scroll(scrollReq, RequestOptions.DEFAULT);
                hits = response.getHits().getHits();
                handleSearchList(hits, descoverProducer);
                processHostCount += hits.length;
            }

            ClearScrollRequest clearScrollReq = new ClearScrollRequest();
            clearScrollReq.addScrollId(scrollId);
            restHighClient.clearScroll(clearScrollReq, RequestOptions.DEFAULT);
        }
        if (processHostCount > 0) {
            // 最新月份的漏洞报告存在数据, 则之前的漏洞实例数据全部标记为历史数据
            vulBiz.markPreviousVulInstanceDataList2History(scanCycle);
            // 标记当前扫描周期为已处理
            vulBiz.saveScanCycleInfo(OpsVulnerabilityScanCycle.from(scanCycle, true));
        }
        log.info("Resolved total of {} vulnerability es datalist for scan cycle {}.", processHostCount, scanCycle);
    }

    private void handleSearchList(final SearchHit[] hits, String discoverProducer) {
        List<Pair<OpsVulnerabilityInstance, List<OpsVulnerability>>> rawResult = new ArrayList<>();

        for (SearchHit hit : hits) {
            DocumentContext ctx = JsonUtil.buildDefaultJsonPathContext(hit.getSourceAsString());
            OpsVulnerabilityInstance vulHost = new OpsVulnerabilityInstance();
            // 修改周期为直接解析出来
//            vulHost.setScanCycle(scanCycle);
            vulHost.setScanCycle(ctx.read("$.scan_cycle"));
            String poolCode = ctx.read("$.poolname");
            vulHost.setPoolName(poolCodeMapName.getOrDefault(poolCode, poolCode));
            vulHost.setHostIp(ctx.read("$.scan_ip"));
            if (StringUtils.isNotBlank(ctx.read("$.manufacturer_type"))) {
                discoverProducer = ctx.read("$.manufacturer_type");
            }
            // 关联cmdb时，获取设备相关数据
//			if (agentLoadType != null && LOAD_FROM_CDMB.equals(agentLoadType.trim())) {
            try {
                Map<String, Object> param = Maps.newHashMap();
                param.put("idcType", vulHost.getPoolName());
                param.put("ip", vulHost.getHostIp());
                param.put("is_cn", true);
                CmdbListResponse.CmdbInstance response = cmdbClient.queryDeviceByRoomIdAndIP(param);
                if (response != null) {
                    vulHost.setDepartment1((String) response.getExtendAttrs().get("department1_orgName_name"));
                    vulHost.setDepartment2((String) response.getExtendAttrs().get("department2_orgName_name"));
                    vulHost.setBizSystem((String) response.getExtendAttrs().get("bizSystem_bizSystem_name"));
                    vulHost.setBizEmployee((String)response.getExtendAttrs().get("biz_employee"));
//				vulHost.setDepartment1Name((String) response.getExtendAttrs().get("department1_orgName_name"));
//				vulHost.setDepartment2Name((String) response.getExtendAttrs().get("department2_orgName_name"));
//				vulHost.setBizSystemName((String) response.getExtendAttrs().get("bizSystem_bizSystem_name"));
                    vulHost.setOsType((String) response.getExtendAttrs().get("device_os_type_dict_note_name"));
                }
            } catch (Exception e) {
                log.error("set cmdb field is error!", e);
            }
//			}
            vulHost.setStatus(VulnerabilityStatus.WAIT_REPAIR);
            vulHost.setReportTime(ctx.read("$.report_time"));

            List<OpsVulnerability> vulDetailList = new ArrayList<>();
            Integer vulCount = ctx.read("$.vulnerability_list.length()", Integer.class);
            for (int i = 0; i < vulCount; i++) {
                OpsVulnerability rawVul = new OpsVulnerability();
                rawVul.setNeedReboot(OpsVulnerability.FLAG_N);
                rawVul.setCanFixed(OpsVulnerability.FLAG_Y);
                rawVul.setDiscoverProducer(discoverProducer);
                rawVul.setName(ctx.read("$.vulnerability_list[" + i + "]['vulnerability_name']"));
                rawVul.setPort(ctx.read("$.vulnerability_list[" + i + "]['port']"));
                rawVul.setProtocol(ctx.read("$.vulnerability_list[" + i + "]['protocol']"));
                rawVul.setService(ctx.read("$.vulnerability_list[" + i + "]['service']"));
                rawVul.setRiskLevel(RiskLevelEnum.fromLabel(ctx.read("$.vulnerability_list[" + i + "]['risk_level']")).getStatusCode());
                rawVul.setRepairMethod(ctx.read("$.vulnerability_list[" + i + "]['repair_method']"));
                rawVul.setDescribe(ctx.read("$.vulnerability_list[" + i + "]['vulnerability_describe']"));
                rawVul.setCveNumber(ctx.read("$.vulnerability_list[" + i + "]['cve_number']"));
                rawVul.setCncveNumber(ctx.read("$.vulnerability_list[" + i + "]['cncve_number']"));
                rawVul.setCnvdNumber(ctx.read("$.vulnerability_list[" + i + "]['cnvd_number']"));
                rawVul.setCnnvdNumber(ctx.read("$.vulnerability_list[" + i + "]['cnnvd_number']"));
//				rawVul.setSystemType(ctx.read("$.vulnerability_list[" + i + "]['operating_system ']"));
//				rawVul.setSystemVersion(ctx.read("$.vulnerability_list[" + i + "]['system_version ']"));
//				rawVul.setPlugVersion(ctx.read("$.vulnerability_list[" + i + "]['plug_version']"));
                vulDetailList.add(rawVul);
            }
            rawResult.add(Pair.of(vulHost, vulDetailList));
        }
        process(rawResult);
    }

    private void process(List<Pair<OpsVulnerabilityInstance, List<OpsVulnerability>>> rawResult) {
        for (Pair<OpsVulnerabilityInstance, List<OpsVulnerability>> pair : rawResult) {

            OpsVulnerabilityInstance vulHost = pair.getKey();

            // 标记已修复数据
            OpsVulnerabilityInstanceQueryModel queryModel = new OpsVulnerabilityInstanceQueryModel();
            queryModel.setHostIp(vulHost.getHostIp());
            queryModel.setPoolName(vulHost.getPoolName());
            queryModel.setScanCycle(vulHost.getScanCycle());
            PageListQueryResult<OpsVulnerabilityInstance> vulPageResult = vulBiz.queryVulnerabilityInstanceList(queryModel);
            if (vulPageResult.getTotalCount() > 0) {
                Set<String> newVulIds = pair.getRight().stream().map(OpsVulnerability::resolveVulId).collect(Collectors.toSet());
                for (OpsVulnerabilityInstance oldVulInst : vulPageResult.getDataList()) {
                    if (!newVulIds.contains(oldVulInst.getVulnerabilityId())) {
                        oldVulInst.setIsFixed(OpsVulnerability.FLAG_Y);
                        vulBiz.updateOpsVulnerabilityInstance(oldVulInst);
                        vulBiz.flushOpsVulnerabilityIsFixed(oldVulInst.getVulnerabilityId(), vulHost.getScanCycle());
                    }
                }
            }
            for (OpsVulnerability vul : pair.getRight()) {
                String vulId = vul.resolveVulId();
                vul.setUpdateTime(new Date());
                if (StringUtils.isBlank(vulId)) {
                    log.warn("The vul record will be ignored as the id is empty '{}'.", vul);
//                    continue;
                    // 找不到漏洞编号时，自生成
                    OpsVulnerability vulResp = vulBiz.getVulnerabilityByName(vul.getName());
                    if (vulResp != null) {
                        vulId = vulResp.getId();
                        vul.setId(vulResp.getId());
                    } else {
                        vulId = UUID.randomUUID().toString();
                        vul.setId(vulId);
                    }
                }
                if (!isVulnerabilityExists(vulId)) {
                    vulBiz.saveVulnerability(vul);
                    // 缓存以避免重复加载
                    cacheOpsVulnerability(vul);
                } else {
                    List<String> portArray = new ArrayList<>(Arrays.asList(existVulCache.get(vulId).getPort().split(",")));
                    if (!portArray.contains(vul.getPort())) {
                        portArray.add(vul.getPort());
                        vul.setPort(Joiner.on(",").join(portArray));
                    }
                    if (existVulCache.get(vulId).getDiscoverProducer() != null && vul.getDiscoverProducer() !=null) {
                        List<String> producerArray = new ArrayList<>(Arrays.asList(existVulCache.get(vulId).getDiscoverProducer().split(",")));
                        if (!producerArray.contains(vul.getDiscoverProducer())) {
                            producerArray.add(vul.getDiscoverProducer());
                            vul.setDiscoverProducer(Joiner.on(",").join(producerArray));
                        }
                    }
                    vulBiz.updateOpsVulnerability(vul);
                    cacheOpsVulnerability(vul);
                }
                OpsVulnerabilityInstance copyInst = vulHost.copy();
                copyInst.setVulnerabilityId(vulId);
                vulBiz.saveOpsVulnerabilityInstance(copyInst);
            }
        }
    }
}
