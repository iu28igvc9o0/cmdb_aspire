package com.aspire.mirror.ops.biz;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.aspire.mirror.ops.api.domain.GeneralResponse;
import com.aspire.mirror.ops.api.domain.PageListQueryResult;
import com.aspire.mirror.ops.api.domain.vulnerability.*;
import com.aspire.mirror.ops.controller.authcontext.RequestAuthContext;
import com.aspire.mirror.ops.dao.OpsVulnerabilityDao;
import com.aspire.mirror.ops.dao.VulnerabilityGroupDao;
import com.aspire.mirror.ops.util.JsonUtil;
import com.google.common.base.Joiner;
import com.google.common.collect.Lists;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang.StringUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.CollectionUtils;

import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.stream.Collectors;

/**
 * TODO
 * <p>
 * 项目名称:  mirror平台
 * 包:        com.aspire.mirror.ops.biz
 * 类名称:    OpsVulnerabilityGroupBiz.java
 * 类描述:    TODO
 * 创建人:    JinSu
 * 创建时间:  2020/7/7 16:14
 * 版本:      v1.0
 */
@Service
@Transactional
@Slf4j
public class OpsVulnerabilityGroupBiz {
    @Autowired
    private VulnerabilityGroupDao vulnerabilityGroupDao;

    @Autowired
    private OpsVulnerabilityDao vulnerabilityDao;

    public PageListQueryResult<VulnerabilityGroup> queryVulnerabilityGroupList(VulnerabilityGroupQueryModel queryParam) {
        List<VulnerabilityGroup> vulnerabilityGroupList = vulnerabilityGroupDao.queryVulnerabilityGroupList(queryParam);
        if (CollectionUtils.isEmpty(vulnerabilityGroupList)) {
            return new PageListQueryResult<VulnerabilityGroup>(0, vulnerabilityGroupList);
        }
        Integer totalCount = vulnerabilityGroupDao.queryVulnerabilityGroupListTotalSize(queryParam);
        return new PageListQueryResult<VulnerabilityGroup>(totalCount, vulnerabilityGroupList);
    }

    public GeneralResponse saveVulnerabilityGroup(VulnerabilityGroup vulnerabilityGroup) {
        String currUser = RequestAuthContext.getRequestHeadUserName();
        VulnerabilityGroup reusltGroup = vulnerabilityGroupDao.queryByName(vulnerabilityGroup.getName());
        if (vulnerabilityGroup.getVulnerabilityGroupId() == null) {
            if (reusltGroup != null) return new GeneralResponse(false, "已经存在该名称漏洞分组");
            vulnerabilityGroup.setCreater(currUser);
            vulnerabilityGroup.setCreateTime(new Date());
            vulnerabilityGroup.setUpdater(currUser);
            vulnerabilityGroup.setUpdateTime(new Date());
            if (vulnerabilityGroup.getOrderNum() == null) {
                vulnerabilityGroup.setOrderNum(vulnerabilityGroupDao.queryLastIndex() + 1);
            }
            vulnerabilityGroupDao.insertVulnerabilityGroup(vulnerabilityGroup);
        } else {
            if (reusltGroup != null && !reusltGroup.getVulnerabilityGroupId().equals(vulnerabilityGroup.getVulnerabilityGroupId()))
                return new GeneralResponse(false, "已经存在该名称漏洞分组");
            vulnerabilityGroup.setUpdater(currUser);
            vulnerabilityGroup.setUpdateTime(new Date());
            vulnerabilityGroupDao.updateVulnerabilityGroup(vulnerabilityGroup);
        }
        // 重新处理漏洞分组
        ExecutorService executor = Executors.newFixedThreadPool(1);
        CompletableFuture.runAsync(() -> {
            List<OpsVulnerability> opsVulnerabilities = vulnerabilityDao.getVulnerabilityList(new OpsVulnerabilityQueryModel());
            for (OpsVulnerability opsVulnerability : opsVulnerabilities) {
                vulnerabilityGroupDao.deleteGroupRelationByVulnerabilityIds(opsVulnerability.getId());
                addVulnerabilityGroupRelation(opsVulnerability);
            }
        }, executor);
        return new GeneralResponse(true, null, vulnerabilityGroup);
    }

    public VulnerabilityGroup getVulnerabilityGroup(Long vulnerabilityGroupId) {
        return vulnerabilityGroupDao.getVulnerabilityGroupById(vulnerabilityGroupId);
    }

    public GeneralResponse removeVulnerabilityGroup(Long vulnerabilityGroupId) {
        List<VulnerabilityGroupRelation> relationList = vulnerabilityGroupDao.queryGroupRelationByVulnerabilityGroupId(vulnerabilityGroupId);
        if (!CollectionUtils.isEmpty(relationList)) {
            return new GeneralResponse(false, "存在关联漏洞，不允许删除");
        }
        vulnerabilityGroupDao.deleteVulnerabilityGroupById(vulnerabilityGroupId);
        return new GeneralResponse();
    }

    public GeneralResponse addVulnerabilityGroupRelation(OpsVulnerability opsVulnerability) {
//        Map<String, Object> vulnerabilyMap = JsonUtil.jacksonConvert(opsVulnerability, Map.class);
        String vulnerablilityString = JsonUtil.toJacksonJson(opsVulnerability).toLowerCase();
        Map<String, Object> vulnerabilyMap = JsonUtil.jacksonConvert(vulnerablilityString, Map.class);
        VulnerabilityGroupQueryModel queryModel = new VulnerabilityGroupQueryModel();
        queryModel.setIsValid(VulnerabilityGroup.IS_VALID_1);
        // 获取所有有效分组
        List<VulnerabilityGroup> listGroup = vulnerabilityGroupDao.queryVulnerabilityGroupList(queryModel);
        List<Long> matchGroupIdList = Lists.newArrayList();
        boolean isFlag = false;
        for (VulnerabilityGroup group : listGroup) {
            String ruleJson = group.getVulnerabilityGroupRule().toLowerCase();
            //解析规则
            JSONArray objects = JSONObject.parseArray(ruleJson);
            //条件为空的忽略
            if (objects == null || objects.isEmpty()) {
                return new GeneralResponse();
            }
            boolean matchFlag = isMatchFlag(vulnerabilyMap, objects);
            if (matchFlag) {
                isFlag = true;
                matchGroupIdList.add(group.getVulnerabilityGroupId());
                VulnerabilityGroupRelation vulnerabilityGroupRelation = new VulnerabilityGroupRelation(group.getVulnerabilityGroupId(), opsVulnerability.getId());
                vulnerabilityGroupDao.insertGroupRelation(vulnerabilityGroupRelation);
                break;
            }
        }
        // 所有未分配分组的漏洞归属到UNKNOW
        if (!isFlag) {
            matchGroupIdList.add(listGroup.get(listGroup.size() - 1).getVulnerabilityGroupId());
            VulnerabilityGroupRelation vulnerabilityGroupRelation = new VulnerabilityGroupRelation(listGroup.get(listGroup.size() - 1).getVulnerabilityGroupId(), opsVulnerability.getId());
            vulnerabilityGroupDao.insertGroupRelation(vulnerabilityGroupRelation);
        }
        return new GeneralResponse(true, null, matchGroupIdList);
    }

    public GeneralResponse addVulnerabilityGroupRelation(VulnerabilityGroupRelation vulnerabilityGroupRelation) {
        vulnerabilityGroupDao.insertGroupRelation(vulnerabilityGroupRelation);
        return new GeneralResponse(true, null, vulnerabilityGroupRelation);
    }

    public GeneralResponse updateVulnerabilityGroupRelation(List<VulnerabilityGroupRelation> vulnerabilityGroupRelationList) {
        if (!CollectionUtils.isEmpty(vulnerabilityGroupRelationList)) {
            Set<String> vulnerabilityIds = vulnerabilityGroupRelationList.stream().map(VulnerabilityGroupRelation::getVulnerabilityId).collect(Collectors.toSet());
            vulnerabilityGroupDao.deleteGroupRelationByVulnerabilityIds(Joiner.on(",").join(vulnerabilityIds));
            for (VulnerabilityGroupRelation relation : vulnerabilityGroupRelationList) {
                vulnerabilityGroupDao.insertGroupRelation(relation);
            }
        }
        return new GeneralResponse(true, null, vulnerabilityGroupRelationList);
    }

    public int deleteVulnerabilityGroupRelationByVulnerabilityIds(String vulnerabilityIds) {
        int result = 0;
        if (StringUtils.isNotEmpty(vulnerabilityIds)) {
            result = vulnerabilityGroupDao.deleteGroupRelationByVulnerabilityIds(vulnerabilityIds);
        }
        return result;
    }

    private boolean isMatchFlag(Map<String, Object> vulnerabilyMap, JSONArray objects) {
        boolean matchFlag = false;
        for (int i = 0; i < objects.size(); i++) {
//            JSONObject andJson = objects.getJSONObject(i);
            JSONArray andlist = objects.getJSONArray(i);
            if (andlist == null || andlist.isEmpty()) {
                continue;
            }
            // 判断条件,单条规则所有条件都符合才能屏蔽
            boolean isolateFlag = isIsolateFlag(vulnerabilyMap, andlist);
            if (isolateFlag) {
                matchFlag = true;
                break;
            }
        }
        return matchFlag;
    }

    private boolean isIsolateFlag(Map<String, Object> vulnerabilyMap, JSONArray andlist) {
        boolean isolateFlag = true;
        for (int j = 0; j < andlist.size(); j++) {
            JSONObject val = andlist.getJSONObject(j);
            String filterItemName = val.getString("filteritemname");
            String operate = val.getString("operate");
            String value = val.getString("value");
            String vulnerValue = vulnerabilyMap.get(filterItemName).toString().toLowerCase();
            if (StringUtils.isEmpty(vulnerValue) || StringUtils.isEmpty(value)) {
                isolateFlag = false;
                continue;
            }
            switch (operate) {
                case "like":
                    List<String> valueList = Arrays.asList(value.split(","));
                    boolean containFlag = false;
                    for (String valueItem : valueList) {
                        if (vulnerValue.contains(valueItem)) {
                            containFlag = true;
                            break;
                        }
                    }
                    isolateFlag = containFlag;
                    break;
                case "=":
                    if (!vulnerValue.equals(value)) {
                        isolateFlag = false;
                    }
                    break;
                case "!=":
                    if (vulnerValue.equals(value)) {
                        isolateFlag = false;
                    }
                    break;
                case "in":
//                    JSONArray inValJson = JSON.parseArray(value);
                    List<String> inValJson = Arrays.asList(value.split(","));
                    if (inValJson == null || !inValJson.contains(vulnerValue)) {
                        isolateFlag = false;
                    }
                    break;
                case "not in":
                    List<String> notValJson = Arrays.asList(value.split(","));
                    if (notValJson != null && notValJson.contains(vulnerValue)) {
                        isolateFlag = false;
                    }
                    break;
                case "exist":
                    List<String> vulnerValueList =Arrays.asList(vulnerValue.split(","));
                    if (!CollectionUtils.isEmpty(vulnerValueList) && !vulnerValueList.contains(value)) {
                        isolateFlag = false;
                    }
                    break;
                case "not exist":
                    List<String> noVulnerValueList =Arrays.asList(vulnerValue.split(","));
                    if (!CollectionUtils.isEmpty(noVulnerValueList) && noVulnerValueList.contains(value)) {
                        isolateFlag = false;
                    }
                    break;
                default:
                    // 包含规则之外的配置，一律判定失败
                    isolateFlag = false;
                    break;
            }
            if (!isolateFlag) break;
        }
        return isolateFlag;
    }
}
