package com.migu.tsg.microservice.atomicservice.composite.controller.opsmanage;

import cn.afterturn.easypoi.excel.ExcelExportUtil;
import cn.afterturn.easypoi.excel.ExcelImportUtil;
import cn.afterturn.easypoi.excel.entity.ImportParams;
import cn.afterturn.easypoi.excel.entity.TemplateExportParams;
import cn.afterturn.easypoi.excel.entity.result.ExcelImportResult;
import cn.afterturn.easypoi.handler.inter.IExcelDataHandler;
import com.aspire.mirror.common.util.ZipUtil;
import com.aspire.mirror.composite.service.opsmanage.ICompOpsVulnerabilityService;
import com.aspire.mirror.ops.api.domain.GeneralResponse;
import com.aspire.mirror.ops.api.domain.PageListQueryResult;
import com.aspire.mirror.ops.api.domain.vulnerability.*;
import com.google.common.collect.Maps;
import com.migu.tsg.microservice.atomicservice.composite.clientservice.opsmanage.VulnerabilityClient;
import com.migu.tsg.microservice.atomicservice.composite.config.VulftpServerConfig;
import com.migu.tsg.microservice.atomicservice.composite.controller.CommonResourceController;
import com.migu.tsg.microservice.atomicservice.composite.controller.authcontext.RequestAuthContext;
import com.migu.tsg.microservice.atomicservice.composite.controller.authcontext.ResAction;
import com.migu.tsg.microservice.atomicservice.composite.controller.handler.VulnerabilityExcelHandler;
import com.migu.tsg.microservice.atomicservice.composite.controller.util.EasyPoiUtil;
import com.migu.tsg.microservice.atomicservice.composite.controller.util.ResourceAuthHelper;
import com.migu.tsg.microservice.atomicservice.composite.controller.util.service.impl.VulnerabilityFtpService;
import com.migu.tsg.microservice.atomicservice.composite.vo.rbac.RbacResource;
import groovy.util.logging.Slf4j;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.tomcat.util.http.fileupload.IOUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ClassPathResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import javax.annotation.PostConstruct;
import javax.servlet.http.HttpServletResponse;
import java.io.*;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * @projectName: CompOpsVulnerabilityController
 * @description: 类
 * @author: luowenbo
 * @create: 2020-07-09 15:56
 **/
@RestController
@Slf4j
public class CompOpsVulnerabilityController extends CommonResourceController implements ICompOpsVulnerabilityService {

    @Autowired
    private VulnerabilityClient vulnerabilityClient;
    private static final String VULNERABILITY_TEMPLATE_PATH = "download/VulnerabilityTemplate.xls";
    private static final String VULNERABILITY_RESOURCE_TEMPLATE_PATH = "download/vulReport.zip";

    private static final String VUL_UPLOAD_PATH = "/vulnerability/upload/%s/%s";

    @Autowired
    private VulftpServerConfig ftpConfig;

    @Autowired
    protected ResourceAuthHelper resAuthHelper;


    @Override
    @ResAction(action = "view", resType = "vulnerability")
    public PageListQueryResult<OpsVulnerability> queryVulnerabilityList(@RequestBody OpsVulnerabilityQueryModel queryParam) {
        return vulnerabilityClient.queryVulnerabilityList(queryParam);
    }

    @Override
    @ResAction(action = "view", resType = "vulnerability")
    public OpsVulnerability getVulnerabilityById(@RequestParam("vulnerabilityId") String vulId) {
        return vulnerabilityClient.getVulnerabilityById(vulId);
    }

    @Override
    @ResAction(action = "update", resType = "vulnerability")
    public GeneralResponse updateVulnerability(@RequestBody OpsVulnerability vul) {
        return vulnerabilityClient.updateVulnerability(vul);
    }

    @Override
    @ResAction(action = "view", resType = "vulnerability")
    public List<Object> getRiskLevelList() {
        return vulnerabilityClient.getRiskLevelList();
    }

    @Override
    @ResAction(action = "view", resType = "vulnerability", loadResFilter = true)
    public PageListQueryResult<OpsVulnerabilityInstance> queryVulnerabilityInstanceList(@RequestBody OpsVulnerabilityInstanceQueryModel queryParam) {
        RequestAuthContext authCtx = RequestAuthContext.currentRequestAuthContext();
        resAuthHelper.resourceActionVerify(authCtx.getUser(), new RbacResource(), authCtx.getResAction(), authCtx.getFlattenConstraints());
        return vulnerabilityClient.queryVulnerabilityInstanceList(queryParam);
    }

    @Override
    @ResAction(action = "view", resType = "vulnerability", loadResFilter = true)
    public void exportVulInstance(@RequestBody OpsVulnerabilityInstanceQueryModel queryParam, HttpServletResponse response) {
        RequestAuthContext authCtx = RequestAuthContext.currentRequestAuthContext();
        resAuthHelper.resourceActionVerify(authCtx.getUser(), new RbacResource(), authCtx.getResAction(), authCtx.getFlattenConstraints());
        PageListQueryResult<OpsVulnerabilityInstance> pageResult = vulnerabilityClient.queryVulnerabilityInstanceList(queryParam);
        String fileName = "vulnerability_instance_export.xls";
//        if (!CollectionUtils.isEmpty(pageResult.getDataList())) {
//            pageResult.getDataList().stream().forEach(item -> {
//                if (item.getRiskLevelDesc() != null) {
//                    item.setRiskLevel(item.getRiskLevelDesc());
//                }
//            });
//        }
        pageResult.getDataList().stream().forEach(item -> {
            if (StringUtils.isEmpty(item.getCanFixed())) {
                item.setCanFixed("Y");
            }
        });
        EasyPoiUtil.exportExcel(pageResult.getDataList(), "漏洞实例导出列表", "漏洞实例列表", OpsVulnerabilityInstance.class, fileName, true, response);
    }

    @Override
    @ResAction(action = "view", resType = "vulnerability", loadResFilter = true)
    public void exportVulInstanceDetail(@RequestBody OpsVulnerabilityInstanceQueryModel queryParam, HttpServletResponse response) {
        RequestAuthContext authCtx = RequestAuthContext.currentRequestAuthContext();
        resAuthHelper.resourceActionVerify(authCtx.getUser(), new RbacResource(), authCtx.getResAction(), authCtx.getFlattenConstraints());
        PageListQueryResult<OpsVulnerabilityInstance> pageResult = vulnerabilityClient.queryVulnerabilityInstanceList(queryParam);
    }

    @Override
    @ResAction(action = "update", resType = "vulnerability")
    public GeneralResponse updateVulInstance(@RequestBody OpsVulnerabilityInstance vulInstance) {
        return vulnerabilityClient.updateVulInstance(vulInstance);
    }

    @Override
    @ResAction(action = "exec", resType = "vulnerability")
    public GeneralResponse executeVulnerabilityRepair(@PathVariable("vulInstanceId") Long vulInstanceId,
                                                      @PathVariable("pipelineId") Long pipelineId) {
        return vulnerabilityClient.executeVulnerabilityRepair(vulInstanceId, pipelineId, OpsVulnerabilityInstance.OPERATE_REPAIR);
    }

    @Override
    @ResAction(action = "go_back", resType = "vulnerability")
    public GeneralResponse executeVulnerabilityGoBack(@PathVariable("vulInstanceId") Long vulInstanceId,
                                                      @PathVariable("pipelineId") Long pipelineId) {
        return vulnerabilityClient.executeVulnerabilityRepair(vulInstanceId, pipelineId, OpsVulnerabilityInstance.OPERATE_GO_BACK);
    }


    @Override
    public void downloadVulnerabilityTemplate(HttpServletResponse response) {
        try {
            TemplateExportParams params = new TemplateExportParams(
                    new File(VULNERABILITY_TEMPLATE_PATH).getCanonicalPath(), true);
            Workbook workbook = ExcelExportUtil.exportExcel(params, Maps.newHashMap());
            // exportFileName代表导出的文件名称
//            ReportUtils.export(response, workbook, exportFileName);
            response.setHeader("Content-Disposition",
                    "attachment;filename=" + new String("漏洞导入模板".getBytes(StandardCharsets.UTF_8), "iso8859-1"));
            response.setContentType("application/vnd.ms-excel;charset=UTF-8");
            response.setHeader("Pragma", "no-cache");
            response.setHeader("Cache-Control", "no-cache");
            response.setDateHeader("Expires", 0);
            BufferedOutputStream bufferedOutPut = new BufferedOutputStream(response.getOutputStream());
            workbook.write(bufferedOutPut);
            bufferedOutPut.flush();
            bufferedOutPut.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
//        String fileName = "vulnerability_template";
//        EasyPoiUtil.exportExcel(new ArrayList<OpsVulnerability>(), "漏洞导入模板", "vulnerability", OpsVulnerability.class, fileName, true,
//                response);

//        Resource res = new ClassPathResource(VULNERABILITY_TEMPLATE_PATH);
//        if (res != null && res.exists()) {
//            BufferedInputStream bis = null;
//            BufferedOutputStream bos = null;
//            try {
//                response.setHeader("content-Type", "application/octet-stream;charset=UTF-8");
//                response.setHeader("Content-Disposition",
//                        "attachment;filename=" + "vulnerability.xls");
//                bis = new BufferedInputStream(res.getInputStream());
//                bos = new BufferedOutputStream(response.getOutputStream());
//                byte[] buff = new byte[2048];
//                int bytesRead;
//                while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) {
//                    bos.write(buff, 0, bytesRead);
//                    bos.flush();
//                }
//            } catch (IOException e) {
//                e.printStackTrace();
//            } finally {
//                try {
//                    if (bis != null) {
//                        bis.close();
//                    }
//                    if (bos != null) {
//                        bos.close();
//                    }
//                } catch (IOException e) {
//                    e.printStackTrace();
//                }
//            }
//        }
    }

    @Override
    public ResponseEntity<String> importVulnerability(@RequestParam("file") MultipartFile file) {
        ImportParams importParams = new ImportParams();
        importParams.setTitleRows(0);
        // 数据处理
        IExcelDataHandler<OpsVulnerability> handler = new VulnerabilityExcelHandler(vulnerabilityClient);
        handler.setNeedHandlerFields(new String[]{"风险等级"});// 注意这里对应的是excel的列名。也就是对象上指定的列名。
        importParams.setDataHandler(handler);
        // 需要验证
        importParams.setNeedVerfiy(true);
        try {
            ExcelImportResult<OpsVulnerability> result = ExcelImportUtil.importExcelMore(file.getInputStream(),
                    OpsVulnerability.class,
                    importParams);

            List<OpsVulnerability> successList = result.getList();
            BatchVulnerabilityRequest batchVulnerabilityRequest = new BatchVulnerabilityRequest();
            batchVulnerabilityRequest.setVulList(successList);
            Map<String, Integer> bathResult = vulnerabilityClient.addBatchVulnerability(batchVulnerabilityRequest);
            return new ResponseEntity<String>(CollectionUtils.isEmpty(successList) ? "操作失败" : "操作成功, 修改漏洞数：" + bathResult.get("update_num") + ", 新增漏洞数：" + bathResult.get("insert_num") + ", 未处理漏洞数：" + bathResult.get("untreated_num"), HttpStatus.OK);
        } catch (Exception e) {
            // 代码审计——系统信息泄露缺陷 luowenbo 20200730
            e.printStackTrace();
            return new ResponseEntity<String>("异常", HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Override
    public void exportVulnerability(@RequestBody OpsVulnerabilityQueryModel queryParam, HttpServletResponse response) {
        PageListQueryResult<OpsVulnerability> pageResult = vulnerabilityClient.queryVulnerabilityList(queryParam);
        String fileName = "vulnerability_export.xls";
        if (!CollectionUtils.isEmpty(pageResult.getDataList())) {
            pageResult.getDataList().stream().forEach(item -> {
                if (item.getRiskLevelDesc() != null) {
                    item.setRiskLevel(item.getRiskLevelDesc());
                }
            });
        }
        EasyPoiUtil.exportExcel(pageResult.getDataList(), "漏洞导出列表", "漏洞列表", OpsVulnerability.class, fileName, true, response);
    }

    @Override
    public GeneralResponse saveVulnerability(@RequestBody OpsVulnerability vul) {
        return vulnerabilityClient.saveVulnerability(vul);
    }

    @Override
    public GeneralResponse saveVulnerabilityInstance(@RequestBody OpsVulnerabilityInstance vul) {
        return vulnerabilityClient.saveVulnerabilityInstance(vul);
    }

    @Override
    public GeneralResponse importVulnerabilityReport(@RequestParam("idcType") String idcType, @RequestParam("scanCycle") String scanCycle, @RequestParam("reportType") String reportType, @RequestParam MultipartFile file) {
        List<OpsVulPoolCodeNameMap> opsVulPoolCodeNameMapList = vulnerabilityClient.loadPoolCodeNameMapList();
        String idcTypeCode = "";
        for (OpsVulPoolCodeNameMap opsVulPoolCodeNameMap : opsVulPoolCodeNameMapList) {
            if (opsVulPoolCodeNameMap.getPoolName().equals(idcType)) {
                idcTypeCode = opsVulPoolCodeNameMap.getPoolCode();
                break;
            }
        }
        String path = String.format(VUL_UPLOAD_PATH, reportType, idcTypeCode);
        logger.info("import vul report path is " + path);
        try {
            VulnerabilityFtpService.upload(ftpConfig.getHost(), ftpConfig.getPort(), ftpConfig.getUsername(), ftpConfig.getPassword(), file.getOriginalFilename(), scanCycle, file.getInputStream(), path);
        } catch (IOException e) {
            return new GeneralResponse(false, "导入异常");
        }
        return new GeneralResponse(true, "已添加漏扫报告文件到解析目录,后台即将处理该报告！");
    }

    @Override
    public List<OpsVulScanCycle> getScanCycleList() {
        return vulnerabilityClient.getScanCycleList();
    }

    @Override
    public OpsVulnerabilityInstanceDetail getVulnerabilityInstanceDetailById(@RequestParam("vulInstanceId") Long vulInstanceId) {
        return vulnerabilityClient.getVulnerabilityInstanceDetailById(vulInstanceId);
    }


    @Override
    public List<OpsVulnerabilityReportItem> vulnerabilityReport(@RequestBody OpsVulnerabilityReportQuery queryParam) {
        return vulnerabilityClient.vulnerabilityReport(queryParam);
    }

    @Override
    public GeneralResponse batchExecuteVulnerabilityRepair(@RequestBody BatchExecuteVulnerabilityReqModel execVulModel) {
        return vulnerabilityClient.batchExecuteVulnerabilityRepair(execVulModel);
    }

    @Override
    public void exportVulnerabilityReport(@RequestBody OpsVulnerabilityReportQuery queryParam, HttpServletResponse response) {
        List<OpsVulnerabilityReportItem> reportItemList = vulnerabilityClient.vulnerabilityReport(queryParam);
        String fileName = "vul_report_export";
        EasyPoiUtil.exportExcel(reportItemList, "漏洞报告导出列表", "漏洞报告列表", OpsVulnerabilityReportItem.class, fileName, true, response);
    }

    @Override
    public GeneralResponse saveVulScanCycle(@RequestBody OpsVulScanCycle opsVulScanCycle) {
        if (opsVulScanCycle == null) {
            logger.error("save sycn cycle body is null");
            return new GeneralResponse(false, "周期不能为空");
        }
        vulnerabilityClient.saveVulScanCycle(opsVulScanCycle);
        return new GeneralResponse(true);
    }

    @Override
    @ResAction(action = "download", resType = "vulnerability")
    public void downloadSourceReport(@RequestBody OpsVulnerabilityReportQuery queryParam, HttpServletResponse response) {
//        RequestAuthContext authCtx = RequestAuthContext.currentRequestAuthContext();
//        resAuthHelper.resourceActionVerify(authCtx.getUser(), new RbacResource(), authCtx.getResAction(), authCtx.getFlattenConstraints());

        if (StringUtils.isEmpty(queryParam.getScanCycle())) {
            logger.error("CompOpsVulnerabilityController[downloadSourceReport] queryParam scanCycle is empty");
            return;
        }
        if (StringUtils.isEmpty(queryParam.getBizSystem())) {
            logger.error("CompOpsVulnerabilityController[downloadSourceReport] queryParam bizSystem is empty");
            return;
        }
        //1 获取漏洞实例列表
        OpsVulNewReportQuery instanceQueryModel = new OpsVulNewReportQuery();
        BeanUtils.copyProperties(queryParam, instanceQueryModel);
        PageListQueryResult<VulReportDetailItem> instancePageResult = vulnerabilityClient.queryVulReportItemList(instanceQueryModel);
        if (instancePageResult.getDataList().size() == 0) {
            logger.error("CompOpsVulnerabilityController[downloadSourceReport] vul instance is empty");
            return;
        }

//        Path tempDir;
        FileInputStream fileInput = null;
        try (OutputStream os = response.getOutputStream()){
            //2 准备文件夹
            Path tempPath = Files.createTempDirectory("_vulReport");
//            File file = ResourceUtils.getFile("download/vulReport/");
//            System.out.println(file);
            Resource res = new ClassPathResource("download/vulReport.zip");

//            FileInputStream inputStream = new FileInputStream(new File ("D:\\vul\\vulReport"));
            Path realTempPath = Paths.get(tempPath.toFile().getAbsolutePath() + "/host/");
            if (!realTempPath.toFile().exists()) {
                Files.createDirectory(realTempPath);
            }
            IOUtils.copy(res.getInputStream(), new FileOutputStream(new File(realTempPath.toFile().getAbsolutePath() + File.separator + "vulReport.zip")));
//            FileUtil.copyFile(res.getFile().getPath(), realTempPath.toFile().getAbsolutePath() + File.separator + "vulReport.zip");
            // 解压漏洞报告模板内容
            String templatePath = realTempPath.toFile().getAbsolutePath() + File.separator + "vulReport.zip";
            String realPath = ZipUtil.unZip(templatePath);
            if (realPath != null) {
                File realFile = new File(realPath);
//            IOUtils.copy(res.getInputStream(), new FileOutputStream(realTempPath.toFile()));
                //3 ftp下载源报告文件
                List<OpsVulPoolCodeNameMap> opsVulPoolCodeNameMapList = vulnerabilityClient.loadPoolCodeNameMapList();
                String idcTypeCode = "";
                for (OpsVulPoolCodeNameMap opsVulPoolCodeNameMap : opsVulPoolCodeNameMapList) {
                    if (opsVulPoolCodeNameMap.getPoolName().equals(instancePageResult.getDataList().get(0).getPoolName())) {
                        idcTypeCode = opsVulPoolCodeNameMap.getPoolCode();
                        break;
                    }
                }
//            for (OpsVulnerabilityInstance instance : instancePageResult.getDataList()) {
                VulnerabilityFtpService.download(ftpConfig.getHost(), ftpConfig.getPort(), ftpConfig.getUsername(), ftpConfig.getPassword(), queryParam.getScanCycle(), idcTypeCode, realPath + File.separator + "vulReport", instancePageResult.getDataList());
//            }
                //4 打包zip
                String generateFileName = realPath + ".zip";
                ZipUtil.toZip(realFile.getAbsolutePath(), generateFileName, true);
                //5 返回文件流

                response.setHeader("Content-Disposition",
                        "attachment;filename*=utf-8'zh_cn'".concat(URLEncoder.encode(queryParam.getBizSystem() + ".zip", "UTF-8")));
                response.setHeader("Connection", "close");
                response.setContentType("application/octet-stream".concat("; charset=UTF-8"));
                // luowenbo 2020-07-24 修改： 代码审计——存储型XSS缺陷
                response.setHeader("Set-Cookie", "cookiename=cookievalue; path=/; Domain=domainvaule; Max- age=seconds; HttpOnly");
                fileInput = new FileInputStream(Paths.get(generateFileName).toFile());
                byte[] buff = new byte[20480];
                int read = 0;
                while ((read = fileInput.read(buff)) > 0) {
                    os.write(buff, 0, read);
                }
                os.flush();
            }
        } catch (Exception e) {
            logger.error("CompOpsVulnerabilityController[downloadSourceReport] prepare directory is error!", e);
            return;
        } finally {
            IOUtils.closeQuietly(fileInput);
        }
    }

    @Override
    public List<VulReportDetailStatistics> queryVulReportDetailStatistics(@RequestBody OpsVulNewReportQuery queryParam) {
        return vulnerabilityClient.queryVulReportDetailStatistics(queryParam);
    }

    @Override
    public PageListQueryResult<VulReportDetailItem> queryVulReportItemList(@RequestBody OpsVulNewReportQuery queryParam) {
        return vulnerabilityClient.queryVulReportItemList(queryParam);
    }

    @Override
    public PageListQueryResult<OpsVulnerabilityNewReportItem> vulNewReport(@RequestBody OpsVulNewReportQuery queryParam) {
        return vulnerabilityClient.vulNewReport(queryParam);
    }

    @Override
    @ResAction(action = "go_back", resType = "vulnerability")
    public GeneralResponse executeVulnerabilityRecheck(@PathVariable("vulInstanceId") Long vulInstanceId,
                                                       @PathVariable("pipelineId") Long pipelineId) {
        return vulnerabilityClient.executeVulnerabilityRepair(vulInstanceId, pipelineId, OpsVulnerabilityInstance.OPERATE_RECHECK);
    }

    @Override
    public void exportVulNewReport(@RequestBody OpsVulNewReportQuery queryParam, HttpServletResponse response) {
        PageListQueryResult<OpsVulnerabilityNewReportItem> pageResult = vulnerabilityClient.vulNewReport(queryParam);
        String fileName = "vulnerability_report_export.xls";
//        if (!CollectionUtils.isEmpty(pageResult.getDataList())) {
//            pageResult.getDataList().stream().forEach(item -> {
//                if (item.getRiskLevelDesc() != null) {
//                    item.setRiskLevel(item.getRiskLevelDesc());
//                }
//            });
//        }
//        pageResult.getDataList().stream().forEach(item -> {
//            if (StringUtils.isEmpty(item.getCanFixed())) {
//                item.setCanFixed("Y");
//            }
//        });
        EasyPoiUtil.exportExcel(pageResult.getDataList(), "漏洞报表列表", "漏洞统计列表", OpsVulnerabilityNewReportItem.class, fileName, true, response);
    }

    @PostConstruct
    private void getTemplatePath() throws IOException {
        File fileDir = new File("download");
//        System.out.println(fileDir.getCanonicalPath());
        if (!fileDir.exists()) {
            Files.createDirectory(Paths.get(fileDir.getCanonicalPath()));
        }

//        File outFile2 = new File(Constant.EXPORT_NEW_TEMPLATE_NAME);
        templateGenereate(VULNERABILITY_TEMPLATE_PATH);
        templateGenereate(VULNERABILITY_RESOURCE_TEMPLATE_PATH);
    }

    private void templateGenereate(String path) throws IOException {
        File outFile = new File(path);
        logger.info("export template path is {}", outFile.getCanonicalPath());
        Files.deleteIfExists(Paths.get(outFile.getCanonicalPath()));
        Files.createFile(Paths.get(outFile.getCanonicalPath()));
        Resource res = new ClassPathResource(path);
        InputStream input = null;
        OutputStream out = null;
        try {
            input = res.getInputStream();
            out = new FileOutputStream(outFile);
            IOUtils.copy(input, out);
        } finally {
            IOUtils.closeQuietly(input);
            IOUtils.closeQuietly(out);
        }
    }

    Logger logger = LoggerFactory.getLogger(CompOpsVulnerabilityController.class);
}
